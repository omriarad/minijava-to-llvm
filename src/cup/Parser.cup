/*************/
/* Based on a template by Oren Ish-Shalom */
/*************/


/*************/
/* IMPORTS */
/*************/

import java_cup.runtime.*;
import ast.*;
import java.util.List;
import java.util.LinkedList;

parser code
{:
	public Lexer lexer;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}

	// Override default error reporting in parser
	public void report_error(String message, Object info)
	{
		System.err.print("Syntax error at line " + lexer.getLine() + " of input. Parser\n");
		System.exit(1);
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
	try {
		s = lexer.next_token();
		return s;
	} catch (java.lang.Error e) {
		System.err.print("Syntax error at line " + lexer.getLine() + " of input. Lexer\n");
		System.exit(1);
		return null;
	}
:};

/*************/
/* TERMINALS */
/*************/
terminal PUBLIC, STATIC, VOID, MAIN, STRING;
terminal CLASS, EXTENDS;
terminal RETURN, IF, ELSE, WHILE;
terminal INT, BOOLEAN;
terminal PRINTLN, LENGTH, TRUE, FALSE, NEW, THIS;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE;
terminal COMMA, DOT, SEMICOLON;
terminal MULT;
terminal PLUS, MINUS;
terminal AND, LESSTHAN;
terminal EQUAL;
terminal NOT;
terminal Integer INTEGER;
terminal String ID;

/*****************/
/* NON TERMINALS */
/*****************/
non terminal Program prog;
non terminal MainClass main_class;
non terminal LinkedList<ClassDecl> class_list;
non terminal ClassDecl class_decl;
non terminal LinkedList<VarDecl> var_decl_list;
non terminal VarDecl var_decl;
non terminal LinkedList<MethodDecl> method_decl_list;
non terminal MethodDecl method_decl;
non terminal LinkedList<FormalArg> formal_list;
non terminal LinkedList<FormalArg> formal_rest_list;
non terminal FormalArg formal_rest;
non terminal LinkedList<Statement> statement_list;
non terminal Statement statement;
non terminal LinkedList<Expr> expr_list;
non terminal Expr expr_rest;
non terminal LinkedList<Expr> expr_rest_list;
non terminal Expr expr;

/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
precedence right EQUAL;
precedence left AND;
precedence right NOT;
precedence left LESSTHAN;
precedence left PLUS, MINUS;
precedence left MULT;
precedence left LBRACKET, RBRACKET;
precedence left DOT;

/************************/
/* INITIAL NON TERMINAL */
/************************/
start with prog;

/********************/
/* PRODUCTION RULES */
/********************/


prog ::= main_class:main class_list:l
	{:
		Program result  = new Program(main, l);
		RESULT = result;
	:}
	;

main_class ::= CLASS ID:id LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID:arg RPAREN LBRACE statement:s RBRACE RBRACE
	{:
		MainClass result  = new MainClass(id, arg, s);
		RESULT = result;
	:}
	;

class_list ::= class_list:l class_decl:c
	{:
		LinkedList<ClassDecl> temp;
		if(l == null) {
			temp = new LinkedList<ClassDecl>();
		}
		else {
			temp = l;
		}
		temp.add(c);
		RESULT = temp;
	:}
	|
	{:
		LinkedList<ClassDecl> result = new LinkedList<ClassDecl>();
		RESULT = result;
	:}
	;

class_decl ::= CLASS ID:name LBRACE var_decl_list:vars method_decl_list:methods RBRACE
	{:
		ClassDecl result  = new ClassDecl(name, null, vars, methods);
		RESULT = result;
	:}
	|
	CLASS ID:name EXTENDS ID:sup LBRACE var_decl_list:vars method_decl_list:methods RBRACE
	{:
		ClassDecl result  = new ClassDecl(name, sup, vars, methods);
		RESULT = result;
	:}
	;

var_decl_list ::= var_decl_list:l var_decl:v
	{:
		LinkedList<VarDecl> temp;
		if(l == null) {
			temp = new LinkedList<VarDecl>();
		}
		else {
			temp = l;
		}
		temp.add(v);
		RESULT = temp;
	:}
	|
	{:
		LinkedList<VarDecl> result  = new LinkedList<VarDecl>();
		RESULT = result;
	:}
	;

var_decl ::= INT LBRACKET RBRACKET ID:name SEMICOLON
	{:
		VarDecl result  = new VarDecl(new IntArrayAstType(), name, nameleft);
		RESULT = result;
	:}
	|
	BOOLEAN ID:name SEMICOLON
	{:
		VarDecl result  = new VarDecl(new BoolAstType(), name, nameleft);
		RESULT = result;
	:}
	|
	INT ID:name SEMICOLON
	{:
		VarDecl result  = new VarDecl(new IntAstType(), name, nameleft);
		RESULT = result;
	:}
	|
	ID:type ID:name SEMICOLON
	{:
		VarDecl result  = new VarDecl(new RefType(type), name, nameleft);
		RESULT = result;
	:}
	;

method_decl_list ::= method_decl_list:l method_decl:m
	{:
		LinkedList<MethodDecl> temp;
		if(l == null) {
			temp = new LinkedList<MethodDecl>();
		}
		else {
			temp = l;
		}
		temp.add(m);
		RESULT = temp;
	:}
	|
	{:
		LinkedList<MethodDecl> result  = new LinkedList<MethodDecl>();
		RESULT = result;
	:}
	;

method_decl ::= PUBLIC INT LBRACKET RBRACKET ID:name LPAREN formal_list:f RPAREN LBRACE var_decl_list:v statement_list:s RETURN expr:e SEMICOLON RBRACE
	{:
		MethodDecl result  = new MethodDecl(new IntArrayAstType(), name, f, v, s, e, nameleft);
		RESULT = result;
	:}
	|
	PUBLIC BOOLEAN ID:name LPAREN formal_list:f RPAREN LBRACE var_decl_list:v statement_list:s RETURN expr:e SEMICOLON RBRACE
	{:
		MethodDecl result  = new MethodDecl(new BoolAstType(), name, f, v, s, e, nameleft);
		RESULT = result;
	:}
	|
	PUBLIC INT ID:name LPAREN formal_list:f RPAREN LBRACE var_decl_list:v statement_list:s RETURN expr:e SEMICOLON RBRACE
	{:
		MethodDecl result  = new MethodDecl(new IntAstType(), name, f, v, s, e, nameleft);
		RESULT = result;
	:}
	|
	PUBLIC ID:type ID:name LPAREN formal_list:f RPAREN LBRACE var_decl_list:v statement_list:s RETURN expr:e SEMICOLON RBRACE
	{:
		MethodDecl result  = new MethodDecl(new RefType(type), name, f, v, s, e, nameleft);
		RESULT = result;
	:}
	;

formal_list ::= INT LBRACKET RBRACKET ID:name formal_rest_list:l
	{:
		FormalArg f = new FormalArg(new IntArrayAstType(), name, nameleft);
		LinkedList<FormalArg> temp = new LinkedList<FormalArg>();
		temp.add(f);
		if(l != null) {
			for(int i=0; i<l.size(); i++) {
				temp.add(l.get(i));
			}
		}
		RESULT = temp;
	:}
	|
	BOOLEAN ID:name formal_rest_list:l
	{:
		FormalArg f = new FormalArg(new BoolAstType(), name, nameleft);
		LinkedList<FormalArg> temp = new LinkedList<FormalArg>();
		temp.add(f);
		if(l != null) {
			for(int i=0; i<l.size(); i++) {
				temp.add(l.get(i));
			}
		}
		RESULT = temp;
	:}
	|
	INT ID:name formal_rest_list:l
	{:
		FormalArg f = new FormalArg(new IntAstType(), name, nameleft);
		LinkedList<FormalArg> temp = new LinkedList<FormalArg>();
		temp.add(f);
		if(l != null) {
			for(int i=0; i<l.size(); i++) {
				temp.add(l.get(i));
			}
		}
		RESULT = temp;
	:}
	|
	ID:type ID:name formal_rest_list:l
	{:
		FormalArg f = new FormalArg(new RefType(type), name, nameleft);
		LinkedList<FormalArg> temp = new LinkedList<FormalArg>();
		temp.add(f);
		if(l != null) {
			for(int i=0; i<l.size(); i++) {
				temp.add(l.get(i));
			}
		}
		RESULT = temp;
	:}
	|
	{:
		LinkedList<FormalArg> result = new LinkedList<FormalArg>();
		RESULT = result;
	:}
	;

formal_rest_list ::= formal_rest_list:l formal_rest:f
	{:
		LinkedList<FormalArg> temp;
		if(l == null) {
			temp = new LinkedList<FormalArg>();

		}
		else {
			temp = l;
		}
		temp.add(f);
		RESULT = temp;
	:}
	|
	{:
		LinkedList<FormalArg> result  = new LinkedList<FormalArg>();
		RESULT = result;
	:}
	;

formal_rest ::= COMMA INT LBRACKET RBRACKET ID:name
	{:
		FormalArg result  = new FormalArg(new IntArrayAstType(), name, nameleft);
		RESULT = result;
	:}
	|
	COMMA BOOLEAN ID:name
	{:
		FormalArg result  = new FormalArg(new BoolAstType(), name, nameleft);
		RESULT = result;
	:}
	|
	COMMA INT ID:name
	{:
		FormalArg result  = new FormalArg(new IntAstType(), name, nameleft);
		RESULT = result;
	:}
	|
	COMMA ID:type ID:name
	{:
		FormalArg result  = new FormalArg(new RefType(type), name, nameleft);
		RESULT = result;
	:}
	;

statement_list ::= statement:s statement_list:l
	{:
		LinkedList<Statement> temp = new LinkedList<Statement>();
		temp.add(s);
		if(l != null) {
			for(int i=0; i<l.size(); i++) {
				temp.add(l.get(i));
			}
		}
		RESULT = temp;
	:}
	|
	{:
		LinkedList<Statement> result  = new LinkedList<Statement>();
		RESULT = result;
	:}
	;

statement ::= LBRACE statement_list:l RBRACE
	{:
		BlockStatement result  = new BlockStatement(l);
		RESULT = result;
	:}
	|
	IF LPAREN expr:e RPAREN statement:if_part ELSE statement:else_part
	{:
		IfStatement result  = new IfStatement(e, if_part, else_part);
		RESULT = result;
	:}
	|
	WHILE LPAREN expr:e RPAREN statement:body
	{:
		WhileStatement result  = new WhileStatement(e, body);
		RESULT = result;
	:}
	|
	PRINTLN:p LPAREN expr:e RPAREN SEMICOLON
	{:
		SysoutStatement result  = new SysoutStatement(e);
		RESULT = result;
	:}
	|
	ID:rhs EQUAL:eq expr:lhs SEMICOLON
	{:
		AssignStatement result  = new AssignStatement(rhs, lhs);
		RESULT = result;
	:}
	|
	ID:array LBRACKET expr:index RBRACKET EQUAL:eq expr:lhs SEMICOLON
	{:
		AssignArrayStatement result  = new AssignArrayStatement(array, index, lhs);
		RESULT = result;
	:}
	;

expr ::=expr:l PLUS:op expr:r
	{:
		AddExpr result  = new AddExpr(l, r);
		RESULT = result;
	:}
	|
	expr:l MINUS:op expr:r
	{:
		SubtractExpr result  = new SubtractExpr(l, r);
		RESULT = result;
	:}
	|
	expr:l MULT:op expr:r
	{:
		MultExpr result  = new MultExpr(l, r);
		RESULT = result;
	:}
	|
	expr:l AND:op expr:r
	{:
		AndExpr result  = new AndExpr(l, r);
		RESULT = result;
	:}
	|
	expr:l LESSTHAN:op expr:r
	{:
		LtExpr result  = new LtExpr(l, r);
		RESULT = result;
	:}
	|
	expr:l LBRACKET:op expr:index RBRACKET
	{:
		ArrayAccessExpr result  = new ArrayAccessExpr(l, index);
		RESULT = result;
	:}
	|
	expr:l DOT:op LENGTH
	{:
		ArrayLengthExpr result  = new ArrayLengthExpr(l);
		RESULT = result;
	:}
	|
	expr:l DOT ID:func LPAREN expr_list:list RPAREN
	{:
		MethodCallExpr result  = new MethodCallExpr(l, func, list);
		RESULT = result;
	:}
	|
	INTEGER:i
	{:
		IntegerLiteralExpr result  = new IntegerLiteralExpr(i.intValue());
		RESULT = result;
	:}
	|
	TRUE:t
	{:
		TrueExpr result  = new TrueExpr();
		RESULT = result;
	:}
	|
	FALSE:f
	{:
		FalseExpr result  = new FalseExpr();
		RESULT = result;
	:}
	|
	ID:name
	{:
		IdentifierExpr result  = new IdentifierExpr(name);
		RESULT = result;
	:}
	|
	THIS:t
	{:
		ThisExpr result  = new ThisExpr();
		RESULT = result;
	:}
	|
	NEW INT LBRACKET expr:size RBRACKET
	{:
		NewIntArrayExpr result  = new NewIntArrayExpr(size);
		RESULT = result;
	:}
	|
	NEW ID:type LPAREN RPAREN
	{:
		NewObjectExpr result  = new NewObjectExpr(type);
		RESULT = result;
	:}
	|
	NOT expr:r
	{:
		NotExpr result = new NotExpr(r);
		RESULT = result;
	:}
	|
	LPAREN expr:e RPAREN
	{:
		RESULT = e;
	:}
	;

expr_list ::= expr:e expr_rest_list:l
	{:
		LinkedList<Expr> temp = new LinkedList<Expr>();
		temp.add(e);
		if(l != null) {
			for(int i=0; i<l.size(); i++)
			{
				temp.add(l.get(i));
			}
		}
		RESULT = temp;
	:}
	|
	{:
		LinkedList<Expr> result  = new LinkedList<Expr>();
		RESULT = result;
	:}
	;

expr_rest_list ::= expr_rest_list:l expr_rest:e
	{:
		LinkedList<Expr> temp;
		if(l == null) {
			temp = new LinkedList<Expr>();

		}
		else {
			temp = l;
		}
		temp.add(e);
		RESULT = temp;
	:}
	|
	;

expr_rest ::= COMMA expr:e
	{:
		RESULT = e;
	:}
	;
