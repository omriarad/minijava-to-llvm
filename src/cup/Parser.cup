/*************/
/* Based on a template by Oren Ish-Shalom */
/*************/


/*************/
/* IMPORTS */
/*************/

import java_cup.runtime.*;
import ast.*;
import java.util.List;
import java.util.LinkedList;

parser code
{:
	public Lexer lexer;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}

	// Override default error reporting in parser
	public void report_error(String message, Object info)
	{
		System.err.print("Syntax error at line " + lexer.getLine() + " of input. Parser\n");
		System.exit(1);
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
	try {
		s = lexer.next_token();
		return s;
	} catch (java.lang.Error e) {
		System.err.print("Syntax error at line " + lexer.getLine() + " of input. Lexer\n");
		System.exit(1);
		return null;
	}
:};

/*************/
/* TERMINALS */
/*************/
/* Classes */
terminal PUBLIC, CLASS, EXTENDS, RETURN;
terminal STATIC, VOID, MAIN, STRING; // Main terminals
/* Statements */
terminal IF, ELSE, WHILE, PRINTLN;
/* Primitives */
terminal INT, BOOLEAN;
/* Objects */
terminal NEW, THIS;
/* Unary expressions */
terminal NOT;
/* Binary expressions */
terminal PLUS, MINUS, MULT, AND, LESSTHAN, EQUAL;
/* Parentheses & delimiters */
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE;
terminal COMMA, DOT, SEMICOLON;
/* Arrays */
terminal LENGTH;
/* Literals */
terminal TRUE, FALSE;
terminal Integer INTLITERAL;
terminal String ID;

/*****************/
/* NON TERMINALS */
/*****************/
/* Ast class definitions */
non terminal Program prog;
non terminal MainClass mainClass;
non terminal ClassDecl classDecl;
non terminal VarDecl var_decl;
non terminal MethodDecl method_decl;
non terminal FormalArg commaPrefixedFormalArg;
non terminal Statement statement;
non terminal Expr expr;
non terminal Expr actual;

/* Ast class lists definitions */
non terminal LinkedList<ClassDecl> classDecls;
non terminal LinkedList<VarDecl> varDecls;
non terminal LinkedList<MethodDecl> methodDecls;
non terminal LinkedList<Statement> statements;
non terminal LinkedList<Expr> exprs;
non terminal LinkedList<FormalArg> formalArgs;
non terminal LinkedList<FormalArg> commaPrefixedFormalArgs;
non terminal LinkedList<Expr> actuals;

/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
precedence right EQUAL;
precedence left AND;
precedence right NOT;
precedence left LESSTHAN;
precedence left PLUS, MINUS;
precedence left MULT;
precedence left LBRACKET, RBRACKET;
precedence left DOT;

/************************/
/* INITIAL NON TERMINAL */
/************************/
start with prog;

/********************/
/* PRODUCTION RULES */
/********************/


prog ::= mainClass:main classDecls:l
	{:
		Program result  = new Program(main, l);
		RESULT = result;
	:}
	;

mainClass ::= CLASS ID:id LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID:arg RPAREN LBRACE statement:s RBRACE RBRACE
	{:
		MainClass result  = new MainClass(id, arg, s);
		RESULT = result;
	:}
	;

classDecls ::= classDecls:l classDecl:c
	{:
		LinkedList<ClassDecl> temp;
		if(l == null) {
			temp = new LinkedList<ClassDecl>();
		}
		else {
			temp = l;
		}
		temp.add(c);
		RESULT = temp;
	:}
	|
	{:
		LinkedList<ClassDecl> result = new LinkedList<ClassDecl>();
		RESULT = result;
	:}
	;

classDecl ::= CLASS ID:name LBRACE varDecls:vars methodDecls:methods RBRACE
	{:
		ClassDecl result  = new ClassDecl(name, null, vars, methods);
		RESULT = result;
	:}
	|
	CLASS ID:name EXTENDS ID:sup LBRACE varDecls:vars methodDecls:methods RBRACE
	{:
		ClassDecl result  = new ClassDecl(name, sup, vars, methods);
		RESULT = result;
	:}
	;

varDecls ::= varDecls:l var_decl:v
	{:
		LinkedList<VarDecl> temp;
		if(l == null) {
			temp = new LinkedList<VarDecl>();
		}
		else {
			temp = l;
		}
		temp.add(v);
		RESULT = temp;
	:}
	|
	{:
		LinkedList<VarDecl> result  = new LinkedList<VarDecl>();
		RESULT = result;
	:}
	;

var_decl ::= INT LBRACKET RBRACKET ID:name SEMICOLON
	{:
		VarDecl result  = new VarDecl(new IntArrayAstType(), name, nameleft);
		RESULT = result;
	:}
	|
	BOOLEAN ID:name SEMICOLON
	{:
		VarDecl result  = new VarDecl(new BoolAstType(), name, nameleft);
		RESULT = result;
	:}
	|
	INT ID:name SEMICOLON
	{:
		VarDecl result  = new VarDecl(new IntAstType(), name, nameleft);
		RESULT = result;
	:}
	|
	ID:type ID:name SEMICOLON
	{:
		VarDecl result  = new VarDecl(new RefType(type), name, nameleft);
		RESULT = result;
	:}
	;

methodDecls ::= methodDecls:l method_decl:m
	{:
		LinkedList<MethodDecl> temp;
		if(l == null) {
			temp = new LinkedList<MethodDecl>();
		}
		else {
			temp = l;
		}
		temp.add(m);
		RESULT = temp;
	:}
	|
	{:
		LinkedList<MethodDecl> result  = new LinkedList<MethodDecl>();
		RESULT = result;
	:}
	;

method_decl ::= PUBLIC INT LBRACKET RBRACKET ID:name LPAREN formalArgs:f RPAREN LBRACE varDecls:v statements:s RETURN expr:e SEMICOLON RBRACE
	{:
		MethodDecl result  = new MethodDecl(new IntArrayAstType(), name, f, v, s, e, nameleft);
		RESULT = result;
	:}
	|
	PUBLIC BOOLEAN ID:name LPAREN formalArgs:f RPAREN LBRACE varDecls:v statements:s RETURN expr:e SEMICOLON RBRACE
	{:
		MethodDecl result  = new MethodDecl(new BoolAstType(), name, f, v, s, e, nameleft);
		RESULT = result;
	:}
	|
	PUBLIC INT ID:name LPAREN formalArgs:f RPAREN LBRACE varDecls:v statements:s RETURN expr:e SEMICOLON RBRACE
	{:
		MethodDecl result  = new MethodDecl(new IntAstType(), name, f, v, s, e, nameleft);
		RESULT = result;
	:}
	|
	PUBLIC ID:type ID:name LPAREN formalArgs:f RPAREN LBRACE varDecls:v statements:s RETURN expr:e SEMICOLON RBRACE
	{:
		MethodDecl result  = new MethodDecl(new RefType(type), name, f, v, s, e, nameleft);
		RESULT = result;
	:}
	;

formalArgs ::= INT LBRACKET RBRACKET ID:name commaPrefixedFormalArgs:l
	{:
		FormalArg f = new FormalArg(new IntArrayAstType(), name, nameleft);
		LinkedList<FormalArg> temp = new LinkedList<FormalArg>();
		temp.add(f);
		if(l != null) {
			for(int i=0; i<l.size(); i++) {
				temp.add(l.get(i));
			}
		}
		RESULT = temp;
	:}
	|
	BOOLEAN ID:name commaPrefixedFormalArgs:l
	{:
		FormalArg f = new FormalArg(new BoolAstType(), name, nameleft);
		LinkedList<FormalArg> temp = new LinkedList<FormalArg>();
		temp.add(f);
		if(l != null) {
			for(int i=0; i<l.size(); i++) {
				temp.add(l.get(i));
			}
		}
		RESULT = temp;
	:}
	|
	INT ID:name commaPrefixedFormalArgs:l
	{:
		FormalArg f = new FormalArg(new IntAstType(), name, nameleft);
		LinkedList<FormalArg> temp = new LinkedList<FormalArg>();
		temp.add(f);
		if(l != null) {
			for(int i=0; i<l.size(); i++) {
				temp.add(l.get(i));
			}
		}
		RESULT = temp;
	:}
	|
	ID:type ID:name commaPrefixedFormalArgs:l
	{:
		FormalArg f = new FormalArg(new RefType(type), name, nameleft);
		LinkedList<FormalArg> temp = new LinkedList<FormalArg>();
		temp.add(f);
		if(l != null) {
			for(int i=0; i<l.size(); i++) {
				temp.add(l.get(i));
			}
		}
		RESULT = temp;
	:}
	|
	{:
		LinkedList<FormalArg> result = new LinkedList<FormalArg>();
		RESULT = result;
	:}
	;

commaPrefixedFormalArgs ::= commaPrefixedFormalArgs:l commaPrefixedFormalArg:f
	{:
		LinkedList<FormalArg> temp;
		if(l == null) {
			temp = new LinkedList<FormalArg>();

		}
		else {
			temp = l;
		}
		temp.add(f);
		RESULT = temp;
	:}
	|
	{:
		LinkedList<FormalArg> result  = new LinkedList<FormalArg>();
		RESULT = result;
	:}
	;

commaPrefixedFormalArg ::= COMMA INT LBRACKET RBRACKET ID:name
	{:
		FormalArg result  = new FormalArg(new IntArrayAstType(), name, nameleft);
		RESULT = result;
	:}
	|
	COMMA BOOLEAN ID:name
	{:
		FormalArg result  = new FormalArg(new BoolAstType(), name, nameleft);
		RESULT = result;
	:}
	|
	COMMA INT ID:name
	{:
		FormalArg result  = new FormalArg(new IntAstType(), name, nameleft);
		RESULT = result;
	:}
	|
	COMMA ID:type ID:name
	{:
		FormalArg result  = new FormalArg(new RefType(type), name, nameleft);
		RESULT = result;
	:}
	;

statements ::= statement:s statements:l
	{:
		LinkedList<Statement> temp = new LinkedList<Statement>();
		temp.add(s);
		if(l != null) {
			for(int i=0; i<l.size(); i++) {
				temp.add(l.get(i));
			}
		}
		RESULT = temp;
	:}
	|
	{:
		LinkedList<Statement> result  = new LinkedList<Statement>();
		RESULT = result;
	:}
	;

statement ::= LBRACE statements:l RBRACE
	{:
		BlockStatement result  = new BlockStatement(l);
		RESULT = result;
	:}
	|
	IF LPAREN expr:e RPAREN statement:if_part ELSE statement:else_part
	{:
		IfStatement result  = new IfStatement(e, if_part, else_part);
		RESULT = result;
	:}
	|
	WHILE LPAREN expr:e RPAREN statement:body
	{:
		WhileStatement result  = new WhileStatement(e, body);
		RESULT = result;
	:}
	|
	PRINTLN:p LPAREN expr:e RPAREN SEMICOLON
	{:
		SysoutStatement result  = new SysoutStatement(e);
		RESULT = result;
	:}
	|
	ID:rhs EQUAL:eq expr:lhs SEMICOLON
	{:
		AssignStatement result  = new AssignStatement(rhs, lhs);
		RESULT = result;
	:}
	|
	ID:array LBRACKET expr:index RBRACKET EQUAL:eq expr:lhs SEMICOLON
	{:
		AssignArrayStatement result  = new AssignArrayStatement(array, index, lhs);
		RESULT = result;
	:}
	;

expr ::=expr:l PLUS:op expr:r
	{:
		AddExpr result  = new AddExpr(l, r);
		RESULT = result;
	:}
	|
	expr:l MINUS:op expr:r
	{:
		SubtractExpr result  = new SubtractExpr(l, r);
		RESULT = result;
	:}
	|
	expr:l MULT:op expr:r
	{:
		MultExpr result  = new MultExpr(l, r);
		RESULT = result;
	:}
	|
	expr:l AND:op expr:r
	{:
		AndExpr result  = new AndExpr(l, r);
		RESULT = result;
	:}
	|
	expr:l LESSTHAN:op expr:r
	{:
		LtExpr result  = new LtExpr(l, r);
		RESULT = result;
	:}
	|
	expr:l LBRACKET:op expr:index RBRACKET
	{:
		ArrayAccessExpr result  = new ArrayAccessExpr(l, index);
		RESULT = result;
	:}
	|
	expr:l DOT:op LENGTH
	{:
		ArrayLengthExpr result  = new ArrayLengthExpr(l);
		RESULT = result;
	:}
	|
	expr:l DOT ID:func LPAREN exprs:list RPAREN
	{:
		MethodCallExpr result  = new MethodCallExpr(l, func, list);
		RESULT = result;
	:}
	|
	INTLITERAL:i
	{:
		IntegerLiteralExpr result  = new IntegerLiteralExpr(i.intValue());
		RESULT = result;
	:}
	|
	TRUE:t
	{:
		TrueExpr result  = new TrueExpr();
		RESULT = result;
	:}
	|
	FALSE:f
	{:
		FalseExpr result  = new FalseExpr();
		RESULT = result;
	:}
	|
	ID:name
	{:
		IdentifierExpr result  = new IdentifierExpr(name);
		RESULT = result;
	:}
	|
	THIS:t
	{:
		ThisExpr result  = new ThisExpr();
		RESULT = result;
	:}
	|
	NEW INT LBRACKET expr:size RBRACKET
	{:
		NewIntArrayExpr result  = new NewIntArrayExpr(size);
		RESULT = result;
	:}
	|
	NEW ID:type LPAREN RPAREN
	{:
		NewObjectExpr result  = new NewObjectExpr(type);
		RESULT = result;
	:}
	|
	NOT expr:r
	{:
		NotExpr result = new NotExpr(r);
		RESULT = result;
	:}
	|
	LPAREN expr:e RPAREN
	{:
		RESULT = e;
	:}
	;

exprs ::= expr:e actuals:l
	{:
		LinkedList<Expr> temp = new LinkedList<Expr>();
		temp.add(e);
		if(l != null) {
			for(int i=0; i<l.size(); i++)
			{
				temp.add(l.get(i));
			}
		}
		RESULT = temp;
	:}
	|
	{:
		LinkedList<Expr> result  = new LinkedList<Expr>();
		RESULT = result;
	:}
	;

actuals ::= actuals:l actual:e
	{:
		LinkedList<Expr> temp;
		if(l == null) {
			temp = new LinkedList<Expr>();

		}
		else {
			temp = l;
		}
		temp.add(e);
		RESULT = temp;
	:}
	|
	;

actual ::= COMMA expr:e
	{:
		RESULT = e;
	:}
	;
